// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - Authentication and ownership
model User {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String   @map("password_hash")
  displayName   String   @map("display_name")
  phone         String?
  avatarUrl     String?  @map("avatar_url")
  createdAt     DateTime @default(now()) @map("created_at")
  lastLoginAt   DateTime? @map("last_login_at")
  isActive      Boolean  @default(true) @map("is_active")

  // Relations
  ownedEvents      Event[]  @relation("EventOwner")
  collaborations   EventCollaborator[]

  @@map("users")
}

// Event model - Wedding, party, corporate event, etc.
model Event {
  id          String   @id @default(uuid())
  name        String
  date        DateTime
  location    String?
  status      String   @default("planning")  // planning, active, completed, archived
  ownerUserId String   @map("owner_user_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  owner         User     @relation("EventOwner", fields: [ownerUserId], references: [id], onDelete: Cascade)
  collaborators EventCollaborator[]
  guests        Guest[]
  tables        Table[]
  versions      Version[]
  groups        Group[]
  constraints   SeatingConstraint[]

  @@map("events")
}

// EventCollaborator model - Share events with other users
model EventCollaborator {
  id         String   @id @default(uuid())
  eventId    String   @map("event_id")
  userId     String   @map("user_id")
  role       String   // viewer, editor, admin
  invitedBy  String   @map("invited_by")
  invitedAt  DateTime @default(now()) @map("invited_at")
  acceptedAt DateTime? @map("accepted_at")
  status     String   @default("active")  // invited, active, removed
  
  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("event_collaborators")
}

// TODO: Add remaining models from DATABASE_SCHEMA.md
// This is a basic starter schema. The full schema will be added in the next phase.
// Placeholder comments for remaining models:

// Guest model - People attending the event
// Group model - Organize guests (family, friends, colleagues)  
// Version model - Different seating arrangements for same event
// Table model - Physical tables in venue
// TableAssignment model - Link guest to table in specific version
// SeatingConstraint model - Guest relationships (must/must-not sit together)

model Guest {
  id                   String   @id @default(uuid())
  eventId              String   @map("event_id")
  name                 String
  lastName             String?  @map("last_name")
  email                String?
  phone                String?
  guestType            String   @default("primary")  // primary, companion, child
  primaryGuestId       String?  @map("primary_guest_id")
  dietaryRestrictions  String[] @map("dietary_restrictions")
  allergies            String?  // Free text for medical allergies
  hasSevereAllergies   Boolean  @default(false) @map("has_severe_allergies")
  mealNotes            String?  @map("meal_notes")
  currentGroup         String?  @map("current_group")
  side                 String?  // bride, groom (for weddings)
  rsvpStatus           String   @default("pending")  // pending, confirmed, declined
  addedByUser          String   @map("added_by_user")
  approved             Boolean  @default(true)  // For approval workflows
  notes                String?
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relations
  event          Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  group          Group?   @relation(fields: [currentGroup], references: [id])
  primaryGuest   Guest?   @relation("GuestCompanions", fields: [primaryGuestId], references: [id])
  companions     Guest[]  @relation("GuestCompanions")
  assignments    TableAssignment[]
  constraintsAs1 SeatingConstraint[] @relation("Guest1")
  constraintsAs2 SeatingConstraint[] @relation("Guest2")

  @@map("guests")
}

model Group {
  id                String   @id @default(uuid())
  eventId           String   @map("event_id")
  name              String
  color             String   @default("blue")
  seatingPreference String   @default("no_preference")  // must_sit_together, prefer_together, can_split, no_preference
  preferAdjacent    Boolean  @default(false)  @map("prefer_adjacent")
  priority          String   @default("medium")  // high, medium, low
  notes             String?
  createdAt         DateTime @default(now()) @map("created_at")

  // Relations
  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  members Guest[]

  @@map("groups")
}

model Version {
  id              String   @id @default(uuid())
  eventId         String   @map("event_id")
  versionNumber   Int      @map("version_number")
  name            String
  description     String?
  isActive        Boolean  @default(false)  @map("is_active")
  hallDimensions  Json?    @map("hall_dimensions")  // { width: 1000, height: 800, unit: "pixels" }
  createdByUser   String   @map("created_by_user")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  event       Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tables      Table[]
  assignments TableAssignment[]

  @@unique([eventId, versionNumber])
  @@map("versions")
}

model Table {
  id           String   @id @default(uuid())
  versionId    String   @map("version_id")
  eventId      String   @map("event_id")
  name         String
  number       Int
  totalSeats   Int      @map("total_seats")
  shape        String   @default("Circle")  // Circle, Rectangle, Square
  section      String?  // "Main Hall", "Balcony", "VIP"
  position     Json     // { x: 100, y: 200 }
  color        String?
  adjacentTables String[] @map("adjacent_tables")  // Array of table IDs
  isReserved   Boolean  @default(false)  @map("is_reserved")
  notes        String?
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  version     Version           @relation(fields: [versionId], references: [id], onDelete: Cascade)
  event       Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  assignments TableAssignment[]

  @@map("tables")
}

model TableAssignment {
  id          String   @id @default(uuid())
  versionId   String   @map("version_id")
  guestId     String   @map("guest_id")
  tableId     String   @map("table_id")
  seatNumber  Int?     @map("seat_number")
  isAttending Boolean  @default(true)  @map("is_attending")  // Can exclude guest from version
  assignedAt  DateTime @default(now()) @map("assigned_at")
  assignedBy  String?  @map("assigned_by")

  // Relations
  version Version @relation(fields: [versionId], references: [id], onDelete: Cascade)
  guest   Guest   @relation(fields: [guestId], references: [id], onDelete: Cascade)
  table   Table   @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@unique([versionId, guestId])  // Guest can only be at one table per version
  @@map("table_assignments")
}

model SeatingConstraint {
  id             String   @id @default(uuid())
  eventId        String   @map("event_id")
  guest1Id       String   @map("guest_1_id")
  guest2Id       String   @map("guest_2_id")
  constraintType String   @map("constraint_type")  // must_sit_together, must_not_sit_together
  priority       String   @default("medium")  // high, medium, low
  reason         String?
  createdAt      DateTime @default(now()) @map("created_at")

  // Relations
  event  Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  guest1 Guest @relation("Guest1", fields: [guest1Id], references: [id], onDelete: Cascade)
  guest2 Guest @relation("Guest2", fields: [guest2Id], references: [id], onDelete: Cascade)

  @@unique([guest1Id, guest2Id])  // Can't have duplicate constraints
  @@map("seating_constraints")
}